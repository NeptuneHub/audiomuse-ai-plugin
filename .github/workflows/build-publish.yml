# This is the name of the GitHub Actions workflow.
name: 'ðŸš€ Publish Plugin'

# This section defines when the workflow will run.
on:
  # Run the workflow when a new tag is pushed. This is ideal for releases.
  # Tags should follow semantic versioning, e.g., v1.0.0.
  push:
    tags:
      - 'v*.*.*'

  # Allows you to manually run this workflow from the Actions tab in your repository.
  # This provides a "button" to trigger the release process for a specific tag.
  workflow_dispatch:
    inputs:
      tag:
        description: 'The git tag to build and release (e.g. v1.0.0). The tag must exist.'
        required: true
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel.
jobs:
  # The 'build' job is responsible for compiling the plugin and creating artifacts.
  build:
    runs-on: ubuntu-latest
    # This output will be used by other jobs to know which tag is being processed.
    outputs:
      tag: ${{ steps.get_tag.outputs.TAG }}
    steps:
      # Step 1: Determine the tag to use based on the trigger event.
      - name: Determine Tag
        id: get_tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "TAG=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "TAG=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      # Step 2: Check out the specific tag so the job can access the correct code.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.get_tag.outputs.TAG }}
          # Fetch all history for all branches and tags.
          # This is necessary for the changelog generation step.
          fetch-depth: '0'

      # Step 3: Set up the .NET environment.
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          # Specify the .NET version your plugin targets.
          # Adjust this to match your project's requirements (e.g., '6.0.x', '8.0.x').
          dotnet-version: '8.0.x'

      # Step 4: Generate a changelog based on the commit messages since the last tag.
      - name: Generate Changelog
        run: |
          # Define the range of commits for the changelog.
          # This captures all commits between the previous tag and the current one.
          # Using '@^' gets the tag before the one we checked out.
          COMMIT_RANGE=$(git describe --tags --abbrev=0 @^)..@
          echo "Generating changelog for commit range: ${COMMIT_RANGE}"

          # Create the changelog from git log, formatting each commit as a list item.
          CHANGELOG=$(git log "$COMMIT_RANGE" --oneline --pretty=format:"- %s (%h)")

          # Create an 'artifacts' directory if it doesn't exist.
          mkdir -p ./artifacts

          # Save the generated changelog to a file that will be used for the GitHub Release body.
          echo -e "$CHANGELOG" > ./artifacts/changelog.md
          echo "Changelog generated and saved to ./artifacts/changelog.md"

      # Step 5: Build the Jellyfin plugin using a dedicated action.
      - name: Build Jellyfin Plugin
        uses: oddstr13/jellyfin-plugin-repository-manager@v1.1.1
        with:
          # The name of your plugin's .csproj file (without the extension).
          # IMPORTANT: You must change 'Jellyfin.Plugin.AudioMuseAi' to match your project's name.
          dotnet-target: 'Jellyfin.Plugin.AudioMuseAi'
          # The path to the directory containing your plugin's source code.
          # This is typically './src'. Adjust if your project structure is different.
          path: './src'
          # The directory where the final build artifact (the .zip file) will be placed.
          output: './artifacts'

      # Step 6: Upload the build artifacts (the .zip file and the changelog).
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: |
            ./artifacts/changelog.md
            ./artifacts/*.zip

  # The 'release' job creates a GitHub Release and attaches the plugin assets.
  release:
    # This job will only run after the 'build' job has completed successfully.
    needs: build
    runs-on: ubuntu-latest
    permissions:
      # This permission is required for the release-action to create a GitHub Release.
      contents: write
    steps:
      # Step 1: Download the artifacts that were uploaded by the 'build' job.
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # Step 2: Prepare the release assets by creating checksum files.
      - name: Prepare GH Release Assets
        run: |
          # Create MD5 and SHA256 checksums for the plugin .zip file.
          for file in ./*.zip; do
            md5sum "${file}" > "${file}.md5"
            sha256sum "${file}" > "${file}.sha256"
          done
          echo "Checksums created."
          ls -l

      # Step 3: Create the GitHub Release using a popular and reliable action.
      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          # A glob pattern to specify which files to upload as release assets.
          artifacts: "./*"
          # Use the changelog file generated earlier as the body for the release notes.
          bodyFile: "./changelog.md"
          # Explicitly set the tag for the release. This makes manual runs reliable.
          tag: ${{ needs.build.outputs.tag }}
          # This ensures the action uses the GITHUB_TOKEN provided by GitHub Actions.
          token: ${{ secrets.GITHUB_TOKEN }}

  # The 'publish' job updates the repository's manifest.json with the new plugin version.
  publish:
    # This job needs the 'release' job to finish and the 'build' job for its tag output.
    needs: [build, release]
    runs-on: ubuntu-latest
    steps:
      # Step 1: Check out the repository again, this time targeting your main branch.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          # IMPORTANT: Change 'main' to 'master' if that is your repository's default branch.
          ref: "main"

      # Step 2: Download the build artifacts again to get the .zip filename.
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # Step 3: Update the manifest.json file with the new release information.
      - name: Update manifest.json
        env:
          # The GITHUB_TOKEN is required to make API calls to get release information.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "::group::Installing JPRM"
          # Install the Jellyfin Plugin Repository Manager tool.
          python3 -m pip install --upgrade jprm
          echo "::endgroup::"

          RELEASE_TAG="${{ needs.build.outputs.tag }}"
          echo "Processing release tag: ${RELEASE_TAG}"

          # Use the GitHub CLI (which is pre-installed on runners) to get the download URL.
          DOWNLOAD_URL=$(gh release view "${RELEASE_TAG}" --json assets --jq '.assets[] | select(.name | endswith(".zip")) | .url')
          echo "Found download URL: ${DOWNLOAD_URL}"

          echo "::group::Updating manifest.json"
          # Use the JPRM tool to add or update the plugin entry in the manifest.json.
          jprm repo add ./manifest.json "$(ls ./*.zip)" -u "${DOWNLOAD_URL}"
          echo "::endgroup::"

      # Step 4: Commit the updated manifest.json file to the repository.
      - name: Commit and Push Changes
        uses: stefanzweifel/git-auto-commit-action@v5
        with:
          # The commit message for the automatic update.
          commit_message: "ci: Update manifest.json for release ${{ needs.build.outputs.tag }}"
          # The branch to push the changes to.
          # IMPORTANT: Change 'main' to 'master' if that is your repository's default branch.
          branch: main
          # Add the repository-wide manifest.json file to the commit.
          file_pattern: 'manifest.json'
