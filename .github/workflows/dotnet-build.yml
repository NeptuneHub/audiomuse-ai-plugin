# Name of the workflow, similar to the Docker example.
name: Build and Release Jellyfin Plugin

# This section mirrors the trigger logic from your Docker example.
on:
  push:
    branches:
      - master      # Trigger for the 'latest' release
    tags:
      - 'v*.*.*'    # Trigger for versioned releases like v1.0.0

jobs:
  # The main job to build and release the plugin.
  build-and-release:
    runs-on: ubuntu-latest

    # This section is equivalent to the permissions in your Docker example.
    # It's critical for allowing the workflow to create GitHub Releases.
    permissions:
      contents: write

    steps:
      # Step 1: Checkout code (same as Docker example).
      - name: Checkout repository
        uses: actions/checkout@v4

      # Step 2: Set up the .NET environment (equivalent to setting up Docker/QEMU).
      - name: Setup .NET 8.0 SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      # Step 3: Restore dependencies (part of the build process).
      - name: Restore NuGet dependencies
        run: dotnet restore ./Jellyfin.Plugin.AudioMuseAi/Jellyfin.Plugin.AudioMuseAi.csproj

      # Step 4: Determine the version number based on the trigger.
      # This is the equivalent of the 'docker/metadata-action' in your example.
      - name: Determine Version
        id: get_version
        run: |
          # If the trigger was a push to the 'master' branch...
          if [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            # ...set the version to a development build number.
            echo "VERSION=0.0.0-dev.${GITHUB_SHA::7}" >> $GITHUB_ENV
          else
            # ...otherwise, if it was a tag, use the tag name as the version.
            echo "VERSION=${GITHUB_REF_NAME#v}" >> $GITHUB_ENV
          fi

      # Step 5: Build the project with the version.
      # This is the equivalent of the 'docker/build-push-action' step.
      - name: Build the plugin
        run: dotnet build --configuration Release --no-restore -p:Version=${{ env.VERSION }} ./Jellyfin.Plugin.AudioMuseAi/Jellyfin.Plugin.AudioMuseAi.csproj

      # Step 6: Create the public GitHub Release.
      # This creates the visible "package" you want for your users.
      - name: Create GitHub Release and Upload Asset
        uses: softprops/action-gh-release@v2
        with:
          # This logic is equivalent to the tagging in your Docker example:
          # - For 'master' branch, tag the release as 'latest'.
          # - For version tags, use the tag name (e.g., 'v1.0.1').
          tag_name: ${{ github.ref == 'refs/heads/master' && 'latest' || github.ref_name }}
          
          # Mark the 'latest' release as a pre-release, as it's a development build.
          prerelease: ${{ github.ref == 'refs/heads/master' }}
          
          # This attaches your final .dll file to the release for users to download.
          files: ./Jellyfin.Plugin.AudioMuseAi/bin/Release/net8.0/Jellyfin.Plugin.AudioMuseAi.dll
