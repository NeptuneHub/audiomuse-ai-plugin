# This is the name of the GitHub Actions workflow.
name: 'ðŸš€ Publish Plugin'

# This section defines when the workflow will run.
on:
  # Run the workflow when a new tag is pushed. This is ideal for releases.
  # Tags should follow semantic versioning, e.g., v*.*.*
  push:
    tags:
      - 'v*.*.*'

  # Allows you to manually run this workflow from the Actions tab in your repository.
  # This provides a "button" to trigger the release process for a specific tag.
  workflow_dispatch:
    inputs:
      tag:
        description: 'The git tag to build and release (e.g. v1.0.0). The tag must exist.'
        required: true
        type: string

# A workflow run is made up of one or more jobs that can run sequentially or in parallel.
jobs:
  # The 'build' job is responsible for compiling the plugin and creating artifacts.
  build:
    runs-on: ubuntu-latest
    # This output will be used by other jobs to know which tag is being processed.
    outputs:
      tag: ${{ steps.get_tag.outputs.TAG }}
    steps:
      # Step 1: Determine the tag to use based on the trigger event.
      - name: Determine Tag
        id: get_tag
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "TAG=${{ inputs.tag }}" >> $GITHUB_OUTPUT
          else
            echo "TAG=${{ github.ref_name }}" >> $GITHUB_OUTPUT
          fi

      # Step 2: Check out the specific tag so the job can access the correct code.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.get_tag.outputs.TAG }}
          # Fetch all history for all branches and tags.
          # This is necessary for the changelog generation step.
          fetch-depth: '0'

      # DEBUGGING STEP: List all files in the checked-out repository to verify build.yaml exists.
      - name: List files in workspace
        run: ls -R

      # Step 3: Set up the .NET environment.
      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          # Specify the .NET version your plugin targets.
          dotnet-version: '8.0.x'

      # Step 4: Generate changelog and update build.yaml
      - name: Generate Changelog and Update Build Config
        run: |
          # Set the path to the build configuration file.
          BUILD_CONFIG_PATH="./Jellyfin.Plugin.AudioMuseAi/build.yaml"
          
          # Get the full tag name from the previous step
          FULL_TAG="${{ steps.get_tag.outputs.TAG }}"
          
          # Remove the leading 'v' from the tag to get the version number with pre-release.
          VERSION_WITH_PRERELEASE=${FULL_TAG#v}
          
          # Strip the pre-release suffix (e.g., -test, -alpha) to get a clean version number.
          VERSION=${VERSION_WITH_PRERELEASE%%-*}

          # Update the version in build.yaml with the correct version number.
          echo "Setting version in build.yaml to $VERSION"
          sed -i "s/version: .*/version: '$VERSION'/" $BUILD_CONFIG_PATH

          # Define the range of commits for the changelog.
          # Use a check to prevent errors on the very first tag.
          if git describe --tags --abbrev=0 @^ >/dev/null 2>&1; then
            COMMIT_RANGE=$(git describe --tags --abbrev=0 @^)..@
          else
            echo "No previous tag found, creating changelog from all commits."
            # This gets all commits leading up to the current one.
            COMMIT_RANGE=$(git rev-list --max-parents=0 HEAD)..@
          fi
          
          echo "Generating changelog for commit range: ${COMMIT_RANGE}"
          CHANGELOG=$(git log "$COMMIT_RANGE" --oneline --pretty=format:"- %s (%h)")

          # If the changelog is empty, provide a default message.
          if [[ -z "$CHANGELOG" ]]; then
            echo "Changelog is empty. Using default message."
            CHANGELOG="- No changes in this release."
          fi

          # Prepare the changelog for YAML multiline format.
          # This replaces the placeholder line with a proper YAML block header.
          sed -i 's/changelog: changelog/changelog: |-\n/' $BUILD_CONFIG_PATH
          # Append the changelog, indented correctly for YAML.
          echo -e "$CHANGELOG" | sed 's/^/    /' >> $BUILD_CONFIG_PATH

          # Create an 'artifacts' directory if it doesn't exist.
          mkdir -p ./artifacts
          # Save the generated changelog to a file for the GitHub Release body.
          echo -e "$CHANGELOG" > ./artifacts/changelog.md
          
          echo "--- Final build.yaml content ---"
          cat $BUILD_CONFIG_PATH
          echo "--------------------------------"
          
          echo "Changelog generated and build.yaml updated."

      # Step 5: Build the Jellyfin plugin using a dedicated action.
      # This action will now find and use the dynamically updated build.yaml.
      - name: Build Jellyfin Plugin
        uses: oddstr13/jellyfin-plugin-repository-manager@v1.1.1
        with:
          # The path to the directory containing your plugin's source code and build.yaml.
          path: './Jellyfin.Plugin.AudioMuseAi'
          # The directory where the final build artifact (the .zip file) will be placed.
          output: './artifacts'

      # Step 6: Upload the build artifacts (the .zip file and the changelog).
      - name: Upload Artifact
        uses: actions/upload-artifact@v4
        with:
          name: build-artifact
          path: |
            ./artifacts/changelog.md
            ./artifacts/*.zip

  # The 'release' job creates a GitHub Release and attaches the plugin assets.
  release:
    # This job will only run after the 'build' job has completed successfully.
    needs: build
    runs-on: ubuntu-latest
    permissions:
      # This permission is required for the release-action to create a GitHub Release.
      contents: write
    steps:
      # Step 1: Download the artifacts that were uploaded by the 'build' job.
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # Step 2: Prepare the release assets by creating checksum files.
      - name: Prepare GH Release Assets
        run: |
          # Create MD5 and SHA256 checksums for the plugin .zip file.
          for file in ./*.zip; do
            md5sum "${file}" > "${file}.md5"
            sha256sum "${file}" > "${file}.sha256"
          done
          echo "Checksums created."
          ls -l

      # Step 3: Create the GitHub Release using a popular and reliable action.
      - name: Create GitHub Release
        uses: ncipollo/release-action@v1
        with:
          # A glob pattern to specify which files to upload as release assets.
          artifacts: "./*"
          # Use the changelog file generated earlier as the body for the release notes.
          bodyFile: "./changelog.md"
          # Explicitly set the tag for the release. This makes manual runs reliable.
          tag: ${{ needs.build.outputs.tag }}
          # This ensures the action uses the GITHUB_TOKEN provided by GitHub Actions.
          token: ${{ secrets.GITHUB_TOKEN }}

  # The 'publish' job updates the repository's manifest.json with the new plugin version.
  publish:
    # This job needs the 'release' job to finish and the 'build' job for its tag output.
    needs: [build, release]
    runs-on: ubuntu-latest
    permissions:
      # This permission is required to push a commit back to the repository.
      contents: write
    steps:
      # Step 1: Check out the repository again, this time targeting your default branch.
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          # Checkout the 'master' branch to push the manifest update.
          ref: "master"

      # Step 2: Download the build artifacts again to get the .zip filename.
      - name: Download Artifact
        uses: actions/download-artifact@v4
        with:
          name: build-artifact

      # Step 3: Update manifest.json using jq for reliability
      - name: Update manifest.json
        env:
          # The GITHUB_TOKEN is required to make API calls to get release information.
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -ex # Exit immediately if a command fails and print each command.

          # --- Define constants and variables ---
          RELEASE_TAG="${{ needs.build.outputs.tag }}"
          VERSION_WITH_PRERELEASE=${RELEASE_TAG#v}
          VERSION=${VERSION_WITH_PRERELEASE%%-*}
          PLUGIN_GUID="e3831be1-c025-4ebc-bc79-121ad0dfc4e1"
          TARGET_ABI="10.10.0.0"

          echo "Processing release tag: ${RELEASE_TAG}"
          echo "Clean version for manifest update is: $VERSION"

          # --- Get required data for the new manifest entry ---
          # Retry loop to wait for the release assets to be available via the API.
          DOWNLOAD_URL=""
          for i in {1..5}; do
            echo "Attempt ${i} to fetch download URL..."
            DOWNLOAD_URL=$(gh release view "${RELEASE_TAG}" --json assets --jq '.assets[] | select(.name | endswith(".zip")) | .browserDownloadUrl')
            if [[ -n "$DOWNLOAD_URL" ]]; then
              break
            fi
            echo "Release asset not found, waiting 10 seconds..."
            sleep 10
          done

          if [[ -z "$DOWNLOAD_URL" ]]; then
            echo "::error::Could not find download URL for release ${RELEASE_TAG} after several attempts. Aborting."
            exit 1
          fi
          echo "Found download URL: ${DOWNLOAD_URL}"

          ZIP_FILE=$(find . -maxdepth 1 -name "*.zip")
          echo "Found ZIP file: $ZIP_FILE"

          CHECKSUM=$(md5sum "$ZIP_FILE" | cut -d' ' -f1)
          echo "Calculated MD5 Checksum: $CHECKSUM"

          CHANGELOG=$(cat changelog.md)
          echo "Read changelog."

          TIMESTAMP=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          echo "Generated timestamp: $TIMESTAMP"

          echo "--- Manifest content BEFORE update ---"
          cat ./manifest.json
          echo "------------------------------------"

          # --- Create the new version object as a JSON string ---
          # We append ".0" to the version to match the 4-part version scheme if needed.
          NEW_VERSION_JSON=$(jq -n \
            --arg version "$VERSION.0" \
            --arg changelog "$CHANGELOG" \
            --arg targetAbi "$TARGET_ABI" \
            --arg sourceUrl "$DOWNLOAD_URL" \
            --arg checksum "$CHECKSUM" \
            --arg timestamp "$TIMESTAMP" \
            '{version: $version, changelog: $changelog, targetAbi: $targetAbi, sourceUrl: $sourceUrl, checksum: $checksum, timestamp: $timestamp}')

          # --- Update the manifest file in place using jq ---
          # 1. Find the object in the top-level array with the correct guid.
          # 2. Update its 'versions' array by:
          #    a. Filtering out any existing version that matches the new one.
          #    b. Prepending the new version object to the start of the array.
          jq \
            --argjson newVersion "$NEW_VERSION_JSON" \
            --arg version_str "$VERSION.0" \
            --arg guid "$PLUGIN_GUID" \
            '(map(if .guid == $guid then .versions |= (map(select(.version != $version_str)) | [$newVersion] + .) else . end))' \
            manifest.json > manifest.tmp && mv manifest.tmp manifest.json

          echo "--- Manifest content AFTER update ---"
          cat ./manifest.json
          echo "-----------------------------------"

      # Step 4: Commit and push the updated manifest.json
      - name: Commit and Push manifest.json
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git add manifest.json
          # Check if there are changes to commit
          if git diff --staged --quiet; then
            echo "No changes to commit."
          else
            echo "Committing updated manifest.json"
            git commit -m "ci: Update manifest.json for release ${{ needs.build.outputs.tag }}"
            git push
          fi
